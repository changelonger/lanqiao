n = int(input())
w = [list(map(int,input().split())) for i in range (n)]
for i in range(1, n):
    for j in range(0, i + 1):
        if j == 0:  # 最左边元素只能由右上方得到
            w[i][j] += w[i - 1][j]
        elif j == i:  # 最右边元素只能由左上方得到
            w[i][j] += w[i - 1][j - 1]  # 注意！第0行一个数，后面第i行有i+1个数
        else:
            w[i][j] += max(w[i-1][j-1:j+1])
if n%2 ==0: # 偶数
    print(max(w[n-1][n//2-1],w[n-1][n//2]))
else:
    print(w[n-1][n//2])

"""
思路：
首先,如果要保证左边和右边对多差1
如果是奇数行,那么向下一共偶数次,要么刚好在中间,要么刚好差2
如果是偶数行,那么一定会差1或者3,所以在中间两个找
这个的思路是,直接在w[i][j]上面加,其实也类似动态规划
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!太牛了
"""